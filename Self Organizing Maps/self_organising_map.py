import csvimport matplotlib as mplfrom mpl_toolkits.mplot3d import Axes3Dimport numpy as npimport matplotlib.pyplot as pltfrom numpy.random import randomimport timeimport math as mimport randomimport networkx as nxdef calculate_distanceMatrix(G,randompoints):	number_of_point = len(randompoints)	#print number_of_point	distance = np.zeros(shape=(number_of_point,number_of_point), dtype=int)	for i in range(0,number_of_point):		for j in range(0,number_of_point):			d = nx.dijkstra_path_length(G, source = randompoints[i], target = randompoints[j])			distance[i,j] = d	#print distance	np.savetxt('distance_matrix.out', distance, delimiter=',')	return distancedef get_eta(eta_0,t,tmax):	return eta_0*(1.0-float(t)/float(tmax))def get_sigma(sigma_0,t,tmax):	return sigma_0*np.exp(-float(t)/float(tmax))pointsX = []pointsY = []pointsZ = []# filename = raw_input('Enter filename with extension : ')filename = 'q3dm1-path1.csv'with open(filename, 'rb') as f:	reader = csv.reader(f)	for row in reader:		data = map(float,row)		pointsX.append(data[0])		pointsY.append(data[1])		pointsZ.append(data[2])point = np.ndarray(shape=(len(pointsX),3), dtype=float, order='F')activity = np.zeros(shape=(len(pointsX),3), dtype=float, order='F')for i in range(0,len(pointsX)):	point[i,0] = pointsX[i]	point[i,1] = pointsY[i]	point[i,2] = pointsZ[i]zl = m.ceil(min(point[:,2])) - 10zh = m.ceil(max(point[:,2])) + 10k = 15randompoints = np.zeros(k, dtype=int)for i in range(0,k):	randompoints[i] = random.randint(0, len(pointsX)-1)graphNode = np.zeros(shape=(k,3), dtype=float, order='F')for i in range(0,k):	graphNode[i] = point[randompoints[i]]G = nx.DiGraph()G.add_nodes_from(randompoints)for i in range(0,k-1):	#wei = np.linalg.norm(point[randompoints[i]]-point[randompoints[i+1]])	G.add_edge(randompoints[i],randompoints[i+1])	G.add_edge(randompoints[i+1],randompoints[i])G.add_edge(randompoints[k-1],randompoints[0])G.add_edge(randompoints[0],randompoints[k-1])nx.circular_layout(G)distance = calculate_distanceMatrix(G,randompoints)tmax = len(point)/10w = np.zeros((tmax+1,k,3))w[0] = graphNodefig = plt.figure(1)fig.clf()ax = Axes3D(fig)ax.set_zlim3d([zl, zh])ax.plot(pointsX, pointsY, pointsZ, '.', c='black')#print w[0],"\n\n"plt.ion()plt.show()iii = 0for t in range(0,tmax):	xi = random.randint(0,len(pointsX)-1)	x = point[xi]	a = np.zeros(k)	for i in range(0,k):		a[i] = np.linalg.norm(x-w[t,i])	i = np.argmin(a)	for j in range(0,k):		first_term = w[t,j]		second_term = get_eta(1.0,t, tmax) * np.exp(-(distance[i,j]/(2*get_sigma(1.0,t,tmax))))		third_term = (x-w[t,j])		#print np.exp(-(distance[i,j]/(2*get_sigma(1.0,t,tmax)))),second_term		w[t+1,j] = first_term + second_term * third_term	fig.clf()	ax = Axes3D(fig)	ax.set_zlim3d([zl, zh])	ax.plot(pointsX, pointsY, pointsZ, '.', c='grey')	ax.scatter(x[0],x[1],x[2], s=200, marker='o', c='black')	ax.scatter(w[t,:,0], w[t,:,1], w[t,:,2], s=200, marker='o', c='b')	ax.plot_wireframe(w[t,:,0], w[t,:,1], w[t,:,2], color='r', linewidths=2)	ax.plot_wireframe(w[t,0:k:k-1,0], w[t,0:k:k-1,1], w[t,0:k:k-1,2], color='r', linewidths=2)	plt.draw()	time.sleep(0.02)		# print w[t,j]	#print w[t+1],"\n\n"		#w[t+1,j] = w[t,j] + get_eta(t, tmax, 1) * np.exp(-(distance[i,j]/(2*get_sigma(t,tmax,1))))*(x-w[t,j])np.savetxt('prototypical_gamestates.out', w[tmax,:,:], delimiter=',')fig.clf()ax = Axes3D(fig)ax.set_zlim3d([zl, zh])ax.plot(pointsX, pointsY, pointsZ, '.', c='grey')ax.scatter(w[tmax,:,0], w[tmax,:,1], w[tmax,:,2], s=200, marker='o', c='b')ax.plot_wireframe(w[tmax,:,0], w[tmax,:,1], w[tmax,:,2], color='r', linewidths=2)ax.plot_wireframe(w[tmax,0:k:k-1,0], w[tmax,0:k:k-1,1], w[tmax,0:k:k-1,2], color='r', linewidths=2)plt.draw()time.sleep(1)